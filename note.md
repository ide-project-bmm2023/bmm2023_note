---
title: "IDE в условиях ограниченных ресурсов"
author:
    - "Даниил Дроздов"
    - "Дарья Коростовская"
    - "Любовь Колбасова"
    - "Александр Волк"
urlcolor: "blue"
mainfont: Iosevka
mathfont: "Fira Math"
exhyphenpenalty: 10000
hyphenpenalty: 10000
---

## Введение

Современную разработку крупных программных продуктов трудно представить без интегрированных сред разработки (Integrated Development Environment, IDE), которые объединяют в себе множество инструментов: редактор кода, отладчик, компоновщик, средство сборки, интеграцию с системами контроля версий и многое другое. IDE экономит массу времени при написании кода обеспечивая программисту такой функционал как:

- Статический анализ[^1]
- Поиск и навигация по кодовой базе
- Удобный и корректный рефакторинг[^2]
- Автодополнение кода

[^1]: Анализ кода без непосредственного его исполнения или компиляции
[^2]: Изменение структуры кода без изменения его поведения; например, почитать про рефакторинги в IntelliJ IDEA можно [тут](https://www.jetbrains.com/help/idea/refactoring-source-code.html)

и прочее.

Несложно заметить что для выполнения этих задач IDE должна иметь некоторый контекст: языка программирования, структуры проекта и кода.

Действительно, как и, например, компилятор, IDE "видит" программный проект не просто как набор текстовых файлов, но строит из них (иногда опираясь как раз на средства компилятора) множество графовых, зачастую древовидных структур данных позволяющих получать все необходимые знания о проекте. Какие именно струкутры будут использоваться зависит от конкретной реализации IDE, но обычно это дерево проекта, включающее AST[^3] конкретных файлов и вспомогательные графы, например зависимости классов (в смысле иерархии наследования или как использования одного класса другим).

[^3]: [Абстрактное синтаксическое дерево](https://ps-group.github.io/compilers/ast)

Но современные кодовые базы вышли далеко за [пределы нескольких миллионов или даже миллиардов строк кода комплексных систем](https://informationisbeautiful.net/visualizations/million-lines-of-code/); вместе с возрастанием объёма кода, возрастают и размеры этих вспомогательных структур, а значит и потребление памяти, использовать обычные рабочие станции в корпаротивной разработке становится проблемотично, поэтому всё чаще можно наблюдать внедрение облачных решений в сфере IDE.

Однако облако - это всего лишь чей-то компьютер, и нагрузка на него всё ещё существует; но здесь нам помогает то, что вычислитель облачной IDE может быть не просто обычной машиной, а сетью, [вычислительным кластером](https://ru.wikipedia.org/wiki/%D0%9A%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80_(%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BE%D0%B2)), где нам становятся доступны все преимущества параллельных вычислений. Цель нашего проекта на мастерской - анализ задачи распределения тех самых вспомогательных графовых структур по разным машинам.

## Задача

Работа алгоритма в своей сути это оптимизационная задача - поиск оптимального относительно целевой функции разбиения графа на кластеры (множества вершин; такие задачи называют кластеризацией графа), каждый кластер загружается в память своей опроеделённой машины. 

> Почему это имеет смысл?

Дело в том, что современные проекты хоть и имеют гигантские масштабы, но пытаются сохранить низкий coupling[^4] и высокую модульность, что безусловно сказывается на виде используемых IDE графов: в дереве проекта модули, отвечающие за разный функционал хранятся в своих пакетах и подпакетах; в графе зависимостей и наследования находятся тесно связанные **сообщества** (например: в одном пакете сосредоточены базовые интерфейсы и их имплементации для ряда задач, а дальше этот набор используется клиентским классом через одну точку - публичный интерфейс).

[^4]: Оно же "сопряжение" модулей программы, подробнее на [вики](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

Таким образом при работе над определённой частью кода, для выполнения большинства задач IDE требуется лишь некоторые подграфы вышеописанных структур, поскольку выделенная в подграфе часть программы скорее всего слабосвязна с наружней. Благодаря этому один компьютер сети будет заниматься обработкой запросов к выделенным ему частям структур. Тем не менее, для корректной работы *всех* функций IDE рано или поздно потребуется информация из других узлов, делать запросы часто - очень дорого, поэтому у заказчика предусмотренна система эффективного кэширования, а при кластеризации нужно так же свести число вероятных запросов к минимуму.

Изначальная постановка задачи оптимизации выходит такой:
$$ X = (g, p) $$
$$ a C_1(X) + b C_2(X) \rightarrow min$$
$$ a + b = 1 $$


где g - некоторый граф, а p - его разбиение

C~1~, C~2~ - целевые функции оценивающие свойства разбиения

a, b - веса, распределяющие вклад каждой из функций в общую оценку

C~1~ оценивает ресурсную стоимость разбиения, а C~2~ стоимость кэша, который может накопиться в процессе работы.

Предполагается что ресурсная стоимость важнее, поэтому коэффиценты были выбраны такие: a = 0.8, b = 0.2; тогда общая ЦФ выглядит так

$$ C = 0.8 C_1(X) + 0.2 C_2(X) \rightarrow min $$

## Модель для исследования

Мы выбрали одну из самых простых моделей, которая подходит для задачи - граф зависимостей классов для Java и несложную целевую функцию. 

В графе зависимостей вершинами являются классы проекта, рёбрами - связи между классами; так же мы дали веса рёбрам - количество связей между классами, то есть число встречаемых в коде одного класса упоминаний другого класса, явных или неявных; это даёт нам контекст для понимания насколько осмысленна та или иная кластеризация с точки зрения завязанных между собой сообществ типов.

Граф строим из написанных на Java проектов. С помощью библиотеки [Spoon](https://github.com/INRIA/spoon) строится мета-модель[^5] проекта. Мета-модель представляет собой дерево, "спуск" (от корня) которого будет выглядеть так: 

корневая вершина -> пакеты -> классы -> члены классов (поля и методы); поддеревья с корнями - классами представляют собой по сути AST этих классов. Обходя поддеревья классов, можно извлечь типы его элементов (например, типы используемых переменных). Подсчитав количество использований одного из классов внутри другого класса, получим вес ребра между вершиной этого класса и используемого. Обойдя все используемые классы для каждого класса в мета-модели проекта, получим нужный граф.

[^5]: Подробнее в [документации Spoon](https://spoon.gforge.inria.fr/structural_elements.html)

Целевая функция же выглядит так:

$$ 0.8 \times N \times M + 0.2 \times n \times k \rightarrow min $$

Здесь

N - кол-во кластеров

M - Max(x_j), x_j - размер кластера (кол-во вершин)

n - Σ ["копируемых" вершин по всем кластерам] (дело в том, что для кэширования нам нужна только одна из вершин, вся информация о подграфе, который содержит эту вершину находится в ней же[^6])

k - стоимость хранения кэшированной информации (была взята константой 0.5)

[^6]: Так нам описал это заказчик.

## Эксперименты

В нашей работе мы остановились на анализе описанной модельной задачи. Мы решили посмотреть как заданная целевая функция ведёт себя при кластеризации известными методами[^7]:

[^7]: Они оптимизируют некоторые другие параметры (не опираясь на данную ЦФ), например модулярность, о которой можно почитать [тут](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BD%D0%B0%D1%83%D0%BA%D0%B0_%D0%BE_%D1%81%D0%B5%D1%82%D1%8F%D1%85)) или [тут](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.community.quality.modularity.html)

### Markov clustering (MCL)

Марковский алгоритм кластеризации основан на потоке (случайном блуждании) в графе. Может быть применен к любым объектам, для которых задана матрица смежности.

Получается, что вероятность перехода (поток) между узлами внутри одного кластера много больше чем между узлами относящимися к разным кластерам. Таким образом, если усиливать поток там, где он силен, и ослаблять его там, где он слаб, то будет выявлена кластерная структура графа.

Сначала происходит преобразование смежной матрицы в матрицу вероятностей переходов между узлами (стохастическую матрицу). Для этого как правило нормируют значения в каждом отдельном столбце матрицы расстояний, однако может быть применен любой другой алгоритм.

После того, как стохастическая матрица получена, к ней поочередно применяют две функции (распространение и накачивание) до тех пор пока матрица изменяется.

1. Распространение (N) - представляет собой возведение матрицы в степень N.
Данная операция усиливает поток из вершины на потенциальных участников кластера. 
1. Накачивание (K) - представляет собой применение произведения Адамара[^8] матрицы самой на себя.

Важные замечания про кластеры:

- Длина пути между узлами одного кластера мала по сравнению с длинно пути между нодами принадлежащими разным кластерам. Для того, чтобы добиться результата "чем больше вес, тем короче путь", мы преобразуем веса на рёбрах n к виду 1/n. 

- При случайном обходе графа, прежде чем покинуть кластер будут посещены многие из его вершин.

[^8]: Бинарная операция над двумя матрицами одинаковой размерности, результатом которой является матрица той же размерности, в которой каждый элемент с индексами i, j — это произведение элементов с индексами i, j исходных матриц

### Label propagation (LPA)

Алгоритм распространения меток - это быстрый алгоритм поиска сообществ в графе. Он выделяет кластеры, используя только саму сетевую структуру, не требует заранее определенной целевой функции или предварительной информации о кластерах.

В исходном состоянии узлы несут ярлык, обозначающий сообщество, к которому они принадлежат. Членство в сообществе меняется в зависимости от меток, которыми обладают соседние узлы. То есть изменение зависит от максимального количества одинаковых меток у соседей данной ноды. Каждый узел инициализируется уникальной меткой, затем метки распространяются по сети. Следовательно, плотно связанные группы быстро приобретают общий ярлык. Когда в сети создается много таких плотных групп (кластеров), они продолжают расширяться, пока это не становится невозможным.

Процесс состоит из 5 шагов:

1. Инициализируйте метки на всех узлах сети. Для данного узла X, C~X~(0) = X.
2. Установите t = 1.
3. Расположите узлы в сети в произвольном порядке и установите значение X.
4. Для каждого узла X, выбранного в этом конкретном порядке, пусть C~X~(t) = f(C~Xi1~(t), ..., C~xim~(t), C~Xi(m + 1)~(t - 1), ..., C~Xik~(t - 1)). 
Здесь возвращается метка, встречающаяся с наибольшей частотой среди соседей. Выберите метку случайным образом, если имеется несколько меток с самой высокой частотой.
5. Если у каждого узла есть метка, которая соответствует максимальному количеству их соседей, остановите алгоритм. В противном случае установите t = t + 1 и перейдите к (3).

### Louvain method

Лувенский метод — один из способов определения кластеров сети. Он подбирает различные кластерные конфигурации, чтобы:

1. Максимизировать число и силу связей между узлами в одном кластере; 
2. Минимизировать при этом связи между узлами различных кластеров. 
Степень удовлетворения этим двум условиям известна как модулярность (modularity), и более высокая модулярность - признак более оптимальных кластеров.

Чтобы получить оптимальную конфигурацию кластеров, лувенский метод итеративно проходит следующие стадии.

Стадия 0: рассматривает каждый узел в качестве кластера, то есть начинает с числа кластеров, равного числу узлов.

Стадия 1: меняет кластерное членство узла, если это приводит к улучшению модулярности. Если модулярность больше нельзя улучшить, узел остается на месте. Это повторяется для каждого узла до тех пор, пока изменения кластерного членства не будут исчерпаны.

Стадия 2: строит грубую версию сети, в которой каждый кластер, найденный на стадии 1, представлен отдельным узлом, и объединяет бывшие межкластерные соединения в утолщенные ребра этих новых узлов в соответствии с их весом.

Стадия 3: повторяет стадии 1 и 2 до тех пор, пока не закончатся дальнейшие изменения членства и размера связей.

Таким образом, лувенский метод помогает нам выявить более значимые кластеры, начав с обнаружения малых из них, а затем при необходимости соединяя их.[^9]

[^9]: Подробнее [тут](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.community.louvain.louvain_communities.html)

### Spectral clustering

Спектральный алгоритм завязан на матрице лапласа и на собственных значениях матрицы лапласа. Для произвольного набора данных (не обязательно для графа, можно для кучи точек) строится матрица лапласа. Затем для этой матрицы ищутся собственные значения.

На основе разниц собственных значений и происходит кластеризация данных. Также матрица лапласа может нам показать количество компонент связности данных: если собственное значение какого-то собственного вектора равно 0, то мы нашли компоненту связности. Количество нулевых собственных значений = количеству компонент связности наших данных (поэтому у нас всегда будет как минимум одно нулевое собственное значение).[^10]

[^10]: [Подробная статья](https://machinelearningmastery.ru/spectral-clustering-aba2640c0d5b/?ysclid=llcqsbjpk8920285549)

## Результаты

Мы оценили поведение ЦФ, её параметров, а так же модулярность при кластеризации каждым из методов на ряде Java проектов (см. [Приложение 1](#appendix)):

$$ %temp_hack_couse_im_stupit $$

### Проект: re

Всего вершин в графе: 23

| Параметр     | Louvain method | MCL     | LPA  | Spectral clustering   |
|--------------|----------------|---------|------|-----------------------|
| ЦФ           | 36.5           | 29.6    | 35.2 | 40.5                  |
| n            | 13             | 8       | 0    | 21                    |
| N            | 4              | 3       | 2    | 4                     |
| M            | 11             | 12      | 22   | 12                    |
| Модулярность | 0.31663        | 0.17915 | 0    | undef.[^11]           |

[^11]: Модулярность посчитать невозможно ввиду возможности пересечения кластеров.

### Проект: Mindustry

Всего вершин в графе: 707

| Параметр     | Louvain method | MCL     | LPA     | Spectral clustering |
|--------------|----------------|---------|---------|---------------------|
| ЦФ           | 3855.0         | 8911.9  | 8200.2  | 3006.5              |
| n            | 1550           | 5215    | 2       | 2945                |
| N            | 37             | 276     | 15      | 30                  |
| M            | 125            | 38      | 690     | 113                 |
| Модулярность | 0.59947        | 0.09307 | 0.01042 | undef.              |

### Проект: WorldEdit

Всего вершин в графе: 1020

| Параметр     | Louvain method | MCL     | LPA     | Spectral clustering |
|--------------|----------------|---------|---------|---------------------|
| ЦФ           | 6908.6         | 9213.9  | 21859.8 | 4447.3              |
| n            | 1502           | 5019    | 110     | 3193                |
| N            | 48             | 330     | 31      | 40                  |
| M            | 176            | 33      | 881     | 129                 |
| Модулярность | 0.68237        | 0.13945 | 0.14684 | undef.              |

### Проект: eclim

Всего вершин в графе: 351

| Параметр     | Louvain method | MCL     | LPA    | Spectral clustering |
|--------------|----------------|--------|---------|---------------------|
| ЦФ           | 6756.0         | 5766.7 | 12262.0 | 2809.0              |
| n            | 136            | 467    | 12      | 10                  |
| N            | 86             | 130    | 79      | 10                  |
| M            | 98             | 55     | 194     | 351                 |
| Модулярность | 0.65013        | 0.2421 | 0.45847 | undef.              |

### Проект: graphhopper

Всего вершин в графе: 983

| Параметр     | Louvain method | MCL     | LPA     | Spectral clustering |
|--------------|----------------|---------|---------|---------------------|
| ЦФ           | 6300.5         | 13697.2 | 18110.4 | 5541.7              |
| n            | 1125           | 5532    | 144     | 1153                |
| N            | 35             | 310     | 29      | 7                   |
| M            | 221            | 53      | 780     | 969                 |
| Модулярность | 0.71337        | 0.10858 | 0.27119 | undef.              |

## Выводы

Исходя из полученных данных и анализа постановки мы выявили:

- Лувенский метод даёт хорошие результаты на данной модели, возможно стоит учитывать модулярность в ЦФ (а так же внедрить модифицированную ЦФ в похожий алгоритм).
- Необходимо откорректировать оценку ресурсной стоимости, минимизировать разброс размеров кластеров (так, например, в *WorldEdit* на LPA мы получили кластер максимального размера 881 при полном размере графа 1020).
- Нужна нормализация для слагаемых ЦФ.
- Можно внедрить вероятностную компоненту, основанную на связях типов; таким образом возможно минимизируется кол-во запросов к слабосвязанным узлам. 

## Благодарности

Наша команда выражает признательность куратору Дмитрию Авзалову и эксперту Степану Фадееву за неутомимый труд на Большой Математической Мастерской, за бесценный опыт для нас и консультации по задаче.

## Приложение 1 {#appendix}

Список Java проектов:

- [re](https://github.com/dkdrozdov/re)
- [Mindustry](https://github.com/Anuken/Mindustry)
- [WorldEdit](https://github.com/EngineHub/WorldEdit)
- [eclim](https://github.com/ervandew/eclim)
- [graphhopper](https://github.com/graphhopper/graphhopper)